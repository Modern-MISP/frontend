<script lang="ts">
  import { invalidateAll } from '$app/navigation';
  import { page } from '$app/stores';
  import { api } from '$lib/api';
  import type { components } from '$lib/api/misp';
  import DynCard from '$lib/components/card/dynCard/DynCard.svelte';
  import Form from '$lib/components/form/Form.svelte';
  import AddTagForm from '$lib/components/tagForms/AddTagForm.svelte';
  import CreateTagForm from '$lib/components/tagForms/CreateTagForm.svelte';
  import type { PickerPill } from '$lib/models/Picker.interface';
  import { notifications } from '$lib/stores';
  import { errorPill, successPill } from '$lib/util/pill.util';
  import { partition } from 'lodash-es';
  import type { PageData } from './$types';
  import EventTags from './EventTags.svelte';
  import { header } from './formHeaders';

  /**
   * Page data containing the data of the event with the id in the url
   */
  export let data: PageData;

  let state: 'addTag' | 'info' | 'createTag' = 'info';

  /**
   * The currently selected pills
   */
  let selection: PickerPill[] = [];

  async function formCallback(formData: Record<string, string>) {
    $api
      .PUT('/events/edit/{eventId}', {
        params: { path: { eventId: data!.event.id! } },
        body: formData as components['requestBodies']['EditEventRequest']['content']['application/json']
      })
      .then(() => notifications.add(successPill('Event updated successfully!')));
  }

  async function addTags(
    tags: {
      local: boolean;
      id: string;
      relation: string;
    }[]
  ) {
    const promises = tags.map(({ id, local }) =>
      $api.POST('/events/addTag/{eventId}/{tagId}/local:{local}', {
        params: {
          path: {
            eventId: $page.params.id,
            tagId: id,
            local: local ? 1 : 0
          }
        },
        headers: {
          'X-Requested-With': 'XMLHttpRequest'
        }
      })
    );

    try {
      const res = await Promise.all(promises);
      // partition the answer into success and error, because misp sends errors with the 200 status...
      const [success, errors] = partition(res, ({ error, data }) => !error && data && !data.errors);

      if (errors.length > 0) {
        notifications.add(errorPill('Some errors occurred. Please refer to the console.'));
        console.error(errors);
      }

      if (success.length > 0) notifications.add(successPill(`Added ${success.length} tags.`));
    } catch (error) {
      notifications.add(
        errorPill(
          'Some external errors occurred. Could also be a cors error. Please refer to the console.'
        )
      );
      console.error(error);
    }

    // Always invalidate, because cors errors are not fatal => tags could be added without notification.
    invalidateAll();

    // TODO: update the relation here, if we have any idea how to get the id. Attention. The required id is another then the id from the tag. It is an event specific idea and I have no clue how to access it.
    // const res = await Promise.all(tags.map(updateRelation));
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async function updateRelation({ id, relation }: { id: string; relation: string }) {
    const endpoint = `tags/modifyTagRelationship/event/{id}`;

    // @ts-expect-error not in the api spec. Don't know how to get the id...
    await $api.POST(endpoint, {
      params: {
        path: {
          id
        }
      },
      body: {
        'data[Tag][relationship_type]': relation
      }
    });
  }
</script>

<!-- 
  @component
  This Page will display the event with a {@link DynCard} component. The header will be generated by the formHeaders depending on the mode. 

  The Galaxies and Tags will be displayed with a {@link PillCollection}.
  The EventGraph will be displayed with the {@link EventGraph} component.
  The Attributes are basically a {@link DynTable}

  The update of the event will be handled by a form inside of this page, that is a wrapper around some DynCards. Therefore the "name" from from any inputted component will be used to calculate the final object we will send to the server. 
 -->

<div class="h-full overflow-auto">
  <Form callback={formCallback}>
    <div class="grid h-full grid-cols-2 gap-2 lg:flex-nowrap">
      {#if state === 'addTag'}
        <AddTagForm
          bind:selection
          on:createTag={() => (state = 'createTag')}
          on:close={() => (state = 'info')}
          on:add={({ detail }) => addTags(detail)}
        />
      {:else if state === 'createTag'}
        <CreateTagForm on:close={() => (state = 'addTag')}></CreateTagForm>
      {:else}
        <section class="h-full">
          <DynCard data={data.event} {header} />
        </section>
      {/if}
      <section class="h-full">
        <EventTags bind:state {data} bind:selection />
      </section>
    </div>
  </Form>
</div>
